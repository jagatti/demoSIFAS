<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>自作リズムゲーム</title>
<style>
  html,body{margin:0;padding:0;width:100%;height:100%;background:#0f172a;overflow:hidden;display:flex;justify-content:center;align-items:center;font-family:system-ui;}
  #rotateMsg{position:fixed;inset:0;z-index:10;background:#000;color:#fff;display:none;justify-content:center;align-items:center;font-size:2rem;}
  #startBtn{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:2.2rem;padding:0.8em 2.2em;background:#39ff14;color:#0f172a;border:none;border-radius:1em;box-shadow:0 6px 32px #39ff1440;cursor:pointer;z-index:100;}
  #startBtn:hover{background:#27ac0e;color:#fff;}
  #retryBtn{position:absolute;right:5vw;top:4vw;min-width:64px;font-size:1.1rem;padding:0.4em 1.1em;background:#ffa500;color:#fff;border:none;border-radius:0.7em;box-shadow:0 2px 10px #ffa50040;cursor:pointer;z-index:101;display:none;opacity:0.94;transition:background 0.2s;}
  #retryBtn:hover{ background:#ff8000; }
  canvas{background:transparent;border:2px solid #334155;border-radius:10px;touch-action:none;display:block;}
</style>
</head>
<body>
<div id="rotateMsg">横画面にしてください</div>
<img id="bgimg" src="bg.jpg" style="display:none;">
<canvas id="game"></canvas>
<button id="startBtn">S.T.A.R.T!!</button>
<button id="retryBtn">リトライ</button>
<audio id="bgm" src="YumeYume.wav" preload="auto" loop></audio>
<script>
  
// --- AC（アピールチャンス）設定（timeベース完全版） ---
const acList = [
  {
    startTime: 12.99,
    endTime: 24.31,
    type: "score",
    target: 1000000,
    rewardScore: 500000,
    rewardSP: 3600,
    state: "waiting",
    progress: 0,
    cleared: false,
    desc: "スコアを100万獲得する",
    tapScore: 0,
    spScore: 0
  },
  {
    startTime: 39.78,
    endTime: 59.22,
    type: "sp",
    target: 3,
    rewardScore: 500000,
    rewardSP: 3600,
    state: "waiting",
    progress: 0,
    cleared: false,
    desc: "SPを3回発動する",
    tapScore: 0,
    spScore: 0
  },
  {
    startTime: 69.22,
    endTime: 72.61,
    type: "score",
    target: 530000,
    rewardScore: 1000000,
    rewardSP: 3600,
    state: "waiting",
    progress: 0,
    cleared: false,
    desc: "スコアを53万獲得する",
    tapScore: 0,
    spScore: 0
  }
];
  
// --- 必ずcvs/ctxなどの変数定義を最初に！ ---
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');
const rotateMsg = document.getElementById('rotateMsg');
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const bgm = document.getElementById('bgm');
const bgimg = document.getElementById('bgimg');
bgm.volume = 0.1;


// --- 譜面データを直接埋め込む ---
const notesChart = [
 {"time": 0.54, "side": "left"},
  {"time": 1.11, "side": "left"},
  {"time": 1.48, "side": "right"},
  {"time": 1.86, "side": "right"},
  {"time": 2.61, "side": "right"},
  {"time": 2.99, "side": "right"},
  {"time": 3.18, "side": "left"},
  {"time": 3.55, "side": "left"},
  {"time": 4.12, "side": "left"},
  {"time": 4.50, "side": "right"},
  {"time": 4.69, "side": "left"},
  {"time": 4.87, "side": "right"},
  {"time": 5.25, "side": "left"},
  {"time": 5.63, "side": "left"},
  {"time": 6.57, "side": "left"},
  {"time": 7.14, "side": "left"},
  {"time": 7.52, "side": "right"},
  {"time": 7.89, "side": "right"},
  {"time": 8.65, "side": "left"},
  {"time": 9.03, "side": "left"},
  {"time": 9.22, "side": "right"},
  {"time": 9.59, "side": "right"},
  {"time": 10.16, "side": "left"},
  {"time": 10.54, "side": "right"},
  {"time": 10.91, "side": "left"},
  {"time": 11.48, "side": "right"},
  {"time": 12.23, "side": "right"},
  {"time": 12.61, "side": "left"},
  {"time": 12.99, "side": "right"},
  {"time": 13.37, "side": "left"},
  {"time": 13.74, "side": "right"},
  {"time": 13.93, "side": "left"},
  {"time": 14.87, "side": "left"},
  {"time": 15.25, "side": "right"},
  {"time": 15.44, "side": "right"},
  {"time": 15.63, "side": "left"},
  {"time": 16.01, "side": "right"},
  {"time": 16.39, "side": "left"},
  {"time": 16.95, "side": "right"},
  {"time": 17.33, "side": "left"},
  {"time": 17.52, "side": "right"},
  {"time": 17.89, "side": "right"},
  {"time": 18.27, "side": "right"},
  {"time": 18.65, "side": "left"},
  {"time": 19.03, "side": "right"},
  {"time": 19.40, "side": "left"},
  {"time": 19.78, "side": "right"},
  {"time": 19.97, "side": "left"},
  {"time": 20.91, "side": "left"},
  {"time": 21.29, "side": "right"},
  {"time": 21.48, "side": "right"},
  {"time": 21.67, "side": "left"},
  {"time": 22.05, "side": "right"},
  {"time": 22.43, "side": "left"},
  {"time": 22.99, "side": "right"},
  {"time": 23.37, "side": "left"},
  {"time": 23.55, "side": "right"},
  {"time": 23.93, "side": "left"},
  {"time": 24.12, "side": "left"},
  {"time": 24.31, "side": "right"},
  {"time": 24.69, "side": "left"},
  {"time": 25.45, "side": "right"},
  {"time": 25.82, "side": "right"},
  {"time": 26.20, "side": "left"},
  {"time": 26.76, "side": "left"},
  {"time": 27.33, "side": "right"},
  {"time": 27.71, "side": "right"},
  {"time": 28.09, "side": "right"},
  {"time": 28.28, "side": "right"},
  {"time": 28.65, "side": "left"},
  {"time": 28.84, "side": "right"},
  {"time": 29.22, "side": "left"},
  {"time": 29.78, "side": "left"},
  {"time": 30.35, "side": "right"},
  {"time": 30.73, "side": "right"},
  {"time": 31.11, "side": "left"},
  {"time": 31.29, "side": "right"},
  {"time": 32.23, "side": "left"},
  {"time": 32.61, "side": "right"},
  {"time": 32.80, "side": "left"},
  {"time": 33.18, "side": "right"},
  {"time": 33.37, "side": "right"},
  {"time": 33.74, "side": "right"},
  {"time": 34.50, "side": "left"},
  {"time": 34.87, "side": "left"},
  {"time": 35.25, "side": "right"},
  {"time": 36.01, "side": "left"},
  {"time": 36.77, "side": "right"},
  {"time": 37.14, "side": "right"},
  {"time": 37.33, "side": "left"},
  {"time": 37.71, "side": "left"},
  {"time": 38.08, "side": "right"},
  {"time": 38.46, "side": "right"},
  {"time": 38.65, "side": "right"},
  {"time": 39.03, "side": "left"},
  {"time": 39.41, "side": "right"},
  {"time": 39.78, "side": "left"},
  {"time": 40.16, "side": "right"},
  {"time": 40.54, "side": "left"},
  {"time": 40.91, "side": "right"},
  {"time": 41.11, "side": "left"},
  {"time": 41.48, "side": "left"},
  {"time": 41.67, "side": "right"},
  {"time": 42.05, "side": "left"},
  {"time": 42.80, "side": "left"},
  {"time": 43.18, "side": "right"},
  {"time": 43.55, "side": "left"},
  {"time": 43.75, "side": "left"},
  {"time": 44.12, "side": "left"},
  {"time": 44.31, "side": "right"},
  {"time": 44.69, "side": "right"},
  {"time": 44.88, "side": "right"},
  {"time": 45.07, "side": "left"},
  {"time": 45.44, "side": "right"},
  {"time": 45.62, "side": "left"},
  {"time": 46.57, "side": "left"},
  {"time": 46.96, "side": "right"},
  {"time": 47.14, "side": "left"},
  {"time": 47.52, "side": "right"},
  {"time": 47.90, "side": "right"},
  {"time": 48.27, "side": "left"},
  {"time": 48.46, "side": "right"},
  {"time": 48.84, "side": "left"},
  {"time": 49.03, "side": "left"},
  {"time": 49.22, "side": "right"},
  {"time": 49.59, "side": "right"},
  {"time": 49.76, "side": "left"},
  {"time": 49.97, "side": "right"},
  {"time": 50.35, "side": "left"},
  {"time": 50.92, "side": "right"},
  {"time": 51.29, "side": "left"},
  {"time": 51.48, "side": "right"},
  {"time": 51.86, "side": "left"},
  {"time": 52.23, "side": "right"},
  {"time": 52.61, "side": "left"},
  {"time": 52.99, "side": "right"},
  {"time": 53.18, "side": "left"},
  {"time": 53.56, "side": "left"},
  {"time": 53.75, "side": "right"},
  {"time": 54.12, "side": "left"},
  {"time": 54.87, "side": "left"},
  {"time": 55.25, "side": "right"},
  {"time": 55.63, "side": "left"},
  {"time": 55.82, "side": "left"},
  {"time": 56.20, "side": "left"},
  {"time": 56.39, "side": "right"},
  {"time": 56.76, "side": "right"},
  {"time": 57.14, "side": "left"},
  {"time": 57.90, "side": "right"},
  {"time": 58.27, "side": "right"},
  {"time": 58.65, "side": "left"},
  {"time": 59.03, "side": "right"},
  {"time": 59.22, "side": "left"},
  {"time": 59.60, "side": "left"},
  {"time": 59.78, "side": "right"},
  {"time": 60.16, "side": "left"},
  {"time": 60.54, "side": "right"},
  {"time": 60.73, "side": "right"},
  {"time": 60.92, "side": "right"},
  {"time": 61.29, "side": "right"},
  {"time": 61.67, "side": "left"},
  {"time": 61.86, "side": "left"},
  {"time": 62.05, "side": "right"},
  {"time": 62.43, "side": "left"},
  {"time": 62.80, "side": "right"},
  {"time": 62.99, "side": "left"},
  {"time": 63.37, "side": "left"},
  {"time": 63.56, "side": "right"},
  {"time": 63.94, "side": "right"},
  {"time": 64.69, "side": "right"},
  {"time": 65.07, "side": "right"},
  {"time": 65.45, "side": "left"},
  {"time": 65.82, "side": "right"},
  {"time": 66.20, "side": "left"},
  {"time": 66.39, "side": "right"},
  {"time": 66.57, "side": "right"},
  {"time": 66.95, "side": "left"},
  {"time": 67.52, "side": "right"},
  {"time": 67.90, "side": "left"},
  {"time": 68.27, "side": "right"},
  {"time": 69.22, "side": "left"},
  {"time": 69.60, "side": "right"},
  {"time": 69.97, "side": "left"},
  {"time": 70.54, "side": "right"},
  {"time": 71.11, "side": "right"},
  {"time": 71.48, "side": "left"},
  {"time": 71.86, "side": "right"},
  {"time": 72.23, "side": "left"},
  {"time": 72.43, "side": "left"},
  {"time": 72.61, "side": "right"},
  {"time": 72.99, "side": "left"},
  {"time": 73.56, "side": "left"},
  {"time": 74.12, "side": "right"},
  {"time": 74.50, "side": "left"},
  {"time": 74.87, "side": "right"},
  {"time": 75.26, "side": "right"},
  {"time": 76.01, "side": "right"},
  {"time": 76.39, "side": "right"},
  {"time": 76.76, "side": "left"},
  {"time": 77.14, "side": "left"},
  {"time": 77.33, "side": "right"},
  {"time": 77.71, "side": "left"},
  {"time": 77.90, "side": "left"},
  {"time": 78.28, "side": "right"},
  {"time": 78.65, "side": "right"},
  {"time": 78.84, "side": "right"},
  {"time": 79.03, "side": "left"},
  {"time": 79.56, "side": "left"},
  {"time": 79.97, "side": "right"},
  {"time": 80.35, "side": "right"},
  {"time": 81.11, "side": "left"},
  {"time": 81.48, "side": "left"},
  {"time": 81.67, "side": "right"},
  {"time": 82.05, "side": "right"},
  {"time": 82.61, "side": "left"},
  {"time": 82.99, "side": "right"},
  {"time": 83.37, "side": "left"},
  {"time": 83.93, "side": "right"},
  {"time": 84.31, "side": "right"},
  {"time": 84.88, "side": "left"},
  {"time": 85.07, "side": "left"},
  {"time": 85.44, "side": "right"},
  {"time": 85.82, "side": "left"},
  {"time": 86.20, "side": "right"},
  {"time": 86.39, "side": "left"}
];
  
// --- グローバル変数 ---
let chartIndex = 0, R=30, leftTarget={x:0,y:0,r:0}, rightTarget={x:0,y:0,r:0}, spRadius=80;
let SP_MAX=6000, spValue=0, spFullNotified=false, score=0, combo=0, notes=[], frame=0, noteDuration=55;
let bestScore = Number(localStorage.getItem('bestScore')) || 0;
let spFlashTimer=0, spRingTimer=0, spRingSpeed=20, spRingRange=40, spBoostTimer=0, spCountdownTimer=0, spCountdownValue=0;
let popups=[], hitRings=[], lastInputWasTouch=false;
let gameState = "init", countdownValue = 3, totalNotesSpawned = 0, clearStartFrame = null, resultStartFrame = null;
let skillHistory = [], appealBoostNotes = 0, skillActivationCount = 0, spUseCount = 0, progressDisplay = 0;
let judgeCount = {CRITICAL:0,WONDERFUL:0,GREAT:0,NICE:0,BAD:0,MISS:0};
let spScoreBuffNotes = 0, noteCounter = 0, totalSPUsed = 0, permanentScoreBuff = 0, acFailFlashTimer = 0, waitingClearFrame = null;
let audioContext, tapBuffer = null;
  
// ノーツ到達までの秒数
const noteTravelSec = noteDuration / 60;
  
// 効果音を事前にバッファ化
async function loadTapSE() {
  audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();
  const response = await fetch('tap.wav');
  const arrayBuffer = await response.arrayBuffer();
  tapBuffer = await audioContext.decodeAudioData(arrayBuffer);
}

//
function findClosestNoteIndex(time) {
  let minDiff = Infinity;
  let idx = -1;
  for (let i = 0; i < notesChart.length; i++) {
    const diff = Math.abs(notesChart[i].time - time);
    if (diff < minDiff) {
      minDiff = diff;
      idx = i;
    }
  }
  return idx;
}
  
// --- assignACNoteIndexes ---
function assignACNoteIndexes() {
  for (const ac of acList) {
    // 開始ノーツidx: startTime以上で最初
    ac.startIdx = notesChart.findIndex(n => n.time >= ac.startTime);
    // 終了ノーツidx: endTime以下で最後
    let lastIdx = -1;
    for (let i = 0; i < notesChart.length; i++) {
      if (notesChart[i].time <= ac.endTime) lastIdx = i;
    }
    ac.endIdx = lastIdx;
  }
}
  
// --- コンボボーナス倍率計算 ---
function getComboBonus(combo) {
  if (combo >= 71) return 1.04;
  if (combo >= 51) return 1.03;
  if (combo >= 31) return 1.02;
  if (combo >= 11) return 1.01;
  return 1.0;
}

// 効果音再生
function playTapSE() {
  if (!tapBuffer) return;
  const source = audioContext.createBufferSource();
  source.buffer = tapBuffer;
  source.connect(audioContext.destination);
  source.start(0);
}
  
// --- AC（アピールチャンス）関連（進捗保存のため追加） ---
  acList.forEach(ac => {
    ac.tapScore = 0; // タップで得たスコア
    ac.spScore = 0;  // SP発動で得たスコア
  });
  
// --- AC取得関数 ---
function getActiveACByTime(nowTime) {
  return acList.find(ac =>
    (ac.state === "active" || (ac.state === "cleared" && nowTime >= ac.startTime + noteTravelSec && nowTime <= ac.endTime + noteTravelSec))
    && nowTime >= ac.startTime + noteTravelSec && nowTime <= ac.endTime + noteTravelSec
  );
}
function isACActiveByTime(nowTime) {
  return !!getActiveACByTime(nowTime);
}
function isACClearedNowByTime(nowTime) {
  return !!acList.find(ac =>
    ac.state === "cleared" && nowTime >= ac.startTime + noteTravelSec && nowTime <= ac.endTime + noteTravelSec
  );
}
  
// --- レイアウト・ターゲット位置 ---
function resizeCanvas(){
  const landscape = window.innerWidth >= window.innerHeight;
  if(!landscape){
    rotateMsg.style.display='flex';
    cvs.style.display='none';
    startBtn.style.display='none';
    retryBtn.style.display='none';
    return;
  }
  rotateMsg.style.display='none';
  cvs.style.display='block';
  if(gameState==="init") startBtn.style.display='block';
  else startBtn.style.display='none';
  if(gameState==="result") retryBtn.style.display='block';
  else retryBtn.style.display='none';
  cvs.width = window.innerWidth;
  cvs.height= window.innerHeight;
  const minDim=Math.min(cvs.width, cvs.height);
  R = Math.max(18, Math.round(minDim*0.04));
  const laneGap = R*4.5;
  const targetY = Math.round(cvs.height*0.7);
  leftTarget  ={x: Math.round(cvs.width/2 - laneGap), y: targetY, r: R};
  rightTarget ={x: Math.round(cvs.width/2 + laneGap), y: targetY, r: R};
  spRadius = Math.max(64, Math.round(minDim*0.12));
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function cubicBezier(p0,p1,p2,p3,t){const u=1-t;return {x:u*u*u*p0.x+3*u*u*t*p1.x+3*u*t*t*p2.x+t*t*t*p3.x,y:u*u*u*p0.y+3*u*u*t*p1.y+3*u*t*t*p2.y+t*t*t*p3.y};}
function makePath(side){const target= side==='left'? leftTarget : rightTarget;const startX = side==='left' ? (-R*2-10) : (cvs.width+R*2+10);const start={x:startX, y: target.y - Math.max(180, R*6)};const c1={x: side==='left' ? target.x - Math.max(200,R*6) : target.x + Math.max(200,R*6), y: target.y - Math.max(200,R*6)};const c2={x: side==='left' ? target.x - Math.max(60,R*2)  : target.x + Math.max(60,R*2),  y: target.y - Math.max(40,R*1.3)};const end={x: target.x, y: target.y};return {p0:start,p1:c1,p2:c2,p3:end};}
// --- spawnNoteにchartIdxを持たせる ---
function spawnNote(side, chartIdx){
  notes.push({
    side,
    t:0,
    duration:noteDuration,
    path:makePath(side),
    chartIdx: chartIdx // どの譜面ノーツか記憶
  });
}
function addPopup(text,x,y,ms,type){const d=Math.max(1,Math.round(ms/16.67));popups.push({text,x,y,timer:d,duration:d,type});}
function triggerSPVisual(){ spFlashTimer=10; spRingTimer=spRingSpeed; }
  
// --- AC進行チェック（nowTimeで判定） ---
function updateACOnTap(pointsWithCombo, nowTime) {
  noteCounter++;
  acList.forEach(ac => {
    // --- AC開始時バフ抽選 ---
    if (Math.abs(nowTime - (ac.startTime + noteTravelSec)) < 0.5 && ac.state === "waiting")  {
      ac.state = "active";
      if(Math.random() < 0.3){
        permanentScoreBuff++;
        skillHistory.unshift({text:"[アピール増加永続 5%]", life:180});
        if(skillHistory.length>5) skillHistory.pop();
      }
    }
    if (ac.state === "active" && nowTime >= ac.startTime + noteTravelSec && nowTime <= ac.endTime + noteTravelSec) {
      if (ac.type === "score") {
        ac.tapScore += pointsWithCombo;
        ac.progress = ac.tapScore + ac.spScore;
      }
      // --- AC成功時バフ抽選 ---
      if (!ac.cleared && ac.progress >= ac.target) {
        ac.cleared = true;
        ac.state = "cleared";
        score += ac.rewardScore;
        spValue = Math.min(SP_MAX, spValue + ac.rewardSP);
        skillHistory.unshift({text: `ACクリア報酬 ${ac.rewardScore}`, life:180});
        if(skillHistory.length>5) skillHistory.pop();
        if(Math.random() < 0.3){
          permanentScoreBuff++;
          skillHistory.unshift({text:"[アピール増加永続 5%]", life:180});
          if(skillHistory.length>5) skillHistory.pop();
        }
      }
    }
    // --- AC失敗判定と赤フラッシュ演出 ---
    if (
      ac.state === "active" &&
      nowTime > ac.endTime + noteTravelSec && // AC時間を過ぎた
      !ac.cleared             // まだクリアしてない
    ) {
      ac.state = "ended";
      acFailFlashTimer = 18; // 0.3秒間赤フラッシュ
      skillHistory.unshift({text: "AC失敗！", life:180});
      if(skillHistory.length>5) skillHistory.pop();
    }
  });
}

function updateACOnSPUse(nowTime, spScore) {
  totalSPUsed++;
  acList.forEach(ac => {
    if (ac.state === "active" && nowTime >= ac.startTime + noteTravelSec && nowTime <= ac.endTime + noteTravelSec) {
      if (ac.type === "sp") {
        ac.progress += 1;
        if (!ac.cleared && ac.progress >= ac.target) {
          ac.cleared = true;
          ac.state = "cleared";
          score += ac.rewardScore;
          spValue = Math.min(SP_MAX, spValue + ac.rewardSP);
          skillHistory.unshift({text: `ACクリア報酬 ${ac.rewardScore}`, life:180});
          if(skillHistory.length>5) skillHistory.pop();
        }
      }
      if (ac.type === "score") {
        ac.spScore += spScore;
        ac.progress = ac.tapScore + ac.spScore;
        if (!ac.cleared && ac.progress >= ac.target) {
          ac.cleared = true;
          ac.state = "cleared";
          score += ac.rewardScore;
          spValue = Math.min(SP_MAX, spValue + ac.rewardSP);
          skillHistory.unshift({text: `ACクリア報酬 ${ac.rewardScore}`, life:180});
          if(skillHistory.length>5) skillHistory.pop();
        }
      }
    }
  });
}
  
// ユーザー操作時に一度だけ呼ぶ
window.addEventListener('touchstart', () => {
  if (!audioContext) loadTapSE();
}, { once: true });
window.addEventListener('mousedown', () => {
  if (!audioContext) loadTapSE();
}, { once: true });

  
// --- 基本スコアの計算を一律30000・上限50000に ---
function calcTapBase(){
  let baseRaw = 30000; // 1タップごとに一律
  if (appealBoostNotes > 0) {
    baseRaw = Math.ceil(baseRaw * 1.12);
    appealBoostNotes--;
  }
  return Math.min(50000, baseRaw);
}

// --- 判定ごとのスコア補正 ---
function calcTapScoreAndLabel(dist, baseRaw){
  let label='WONDERFUL', mult=1.2;
  if(dist<=6){label='WONDERFUL';mult=1.2;}
  else if(dist<=10){label='GREAT';mult=1.1;}
  else if(dist<=14){label='NICE';mult=1.0;}
  else if(dist<=18){label='BAD';mult=0.9;}
  else {return {points:0,label:'MISS',reset:true};}
  let points=Math.floor(baseRaw*mult);
  if(Math.random()<0.3){ points=Math.floor(points*1.5); label='CRITICAL'; }
  if(spBoostTimer>0) points=Math.floor(points*1.1);
  points=Math.min(50000, points);
  const reset = (label==='NICE' || label==='BAD');
  return {points,label,reset};
}

// --- スコア加算処理 ---
function awardHit(target, points, label, resetCombo, baseRaw){
  playTapSE();
  let nowTime = bgm.currentTime || 0;
  let acBuff = 1.0;
  if (isACActiveByTime(nowTime) || isACClearedNowByTime(nowTime)) acBuff = 1.1;
  let spBuff = 1.0;
  if (spScoreBuffNotes > 0) {
    spBuff = 1.1;
    spScoreBuffNotes--;
  }
  // --- 永続バフ適用 ---
  let permanentBuff = 1 + permanentScoreBuff * 0.05;
  const comboBonus = getComboBonus(combo+1);
  let pointsWithCombo = Math.floor(points * comboBonus * acBuff * spBuff * permanentBuff);
  if(pointsWithCombo > 50000) pointsWithCombo = 50000;

  score += pointsWithCombo;
  if(resetCombo){if(spValue<SP_MAX) spValue=Math.max(0, spValue-300);combo=0;}
  else combo++;
  spValue=Math.min(SP_MAX, spValue+200);
  hitRings.push({x:target.x,y:target.y,r:target.r,alpha:1});
  const midX = (leftTarget.x + rightTarget.x) / 2;
  const midY = (leftTarget.y + rightTarget.y) / 2 - R*2;
  addPopup(label, midX, midY - 30, 500, 'label');
  addPopup(String(pointsWithCombo), midX, midY, 500, 'score');
  if(judgeCount[label] !== undefined) judgeCount[label]++;
  if(Math.random() < 0.33){
    skillActivationCount++;
    const skillType = Math.floor(Math.random()*3);
    if(skillType===0){
      score += baseRaw;
      skillHistory.unshift({text:`[ボルテージ獲得 ${baseRaw}]`, life:180});
    }else if(skillType===1){
      spValue = Math.min(SP_MAX, spValue+540);
      skillHistory.unshift({text:`[SPゲージ獲得 9%]`, life:180});
    }else{
      appealBoostNotes = 5;
      skillHistory.unshift({text:`[アピール増加 12%]`, life:180});
    }
    if(skillHistory.length>5) skillHistory.pop();
  }
  updateACOnTap(pointsWithCombo, nowTime);
}
  
function applyMiss(label='MISS'){
  if(spValue<SP_MAX) spValue=Math.max(0, spValue-300);
  combo=0;
  const midX = (leftTarget.x + rightTarget.x) / 2;
  const midY = (leftTarget.y + rightTarget.y) / 2 - R*2;
  addPopup(label, midX, midY - 30, 500, 'label');
  if(judgeCount[label] !== undefined) judgeCount[label]++;
}
function isInSPSemicircle(mx,my){
  const cx=cvs.width/2, cy=cvs.height-10, r=spRadius;
  const dx=mx-cx, dy=my-cy, dist=Math.hypot(dx,dy);
  return (dist<=r) && (my<=cy);
}
function judgeNotesGlobal(){
  let bestIdx=-1, bestDist=Infinity, bestTarget=null;
  for(let i=0;i<notes.length;i++){
    const n=notes[i];
    const target=n.side==='left'?leftTarget:rightTarget;
    const pos=cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1,n.t/n.duration));
    const judgeDist=Math.hypot(pos.x-target.x, pos.y-target.y);
    if(judgeDist<bestDist){bestDist=judgeDist; bestIdx=i; bestTarget=target;}
  }
  if(bestIdx>=0){
    const baseRaw = calcTapBase();
    const {points,label,reset}=calcTapScoreAndLabel(bestDist, baseRaw);
    if(label!=='MISS'){
      awardHit(bestTarget, points, label, reset, baseRaw);
      notes.splice(bestIdx,1);
      return true;
    }else{ return false; }
  }
  return false;
}

// --- SPゲージ使用時のスコア計算（上限250000制限を正しく適用） ---
function tryUseSP(mx,my){
  if(spValue<SP_MAX) return false;
  if(!isInSPSemicircle(mx,my)) return false;
  let nowTime = bgm.currentTime || 0;
  spUseCount++;
  let spBase = 180000;
  if (appealBoostNotes > 0) {
    spBase = Math.ceil(spBase * 1.12);
    appealBoostNotes--;
  }
  let permanentBuff = 1 + permanentScoreBuff * 0.05;
  const comboBonus = getComboBonus(combo);
  let spScore = spBase;
  if (isACActiveByTime(nowTime) || isACClearedNowByTime(nowTime)) spScore = Math.floor(spScore * 1.1);
  if(spBoostTimer>0) spScore = Math.floor(spScore * 1.1);
  spScore = Math.floor(spScore * comboBonus * permanentBuff);
  if (spScore > 250000) spScore = 250000;
  score += spScore;
  spValue = 0;
  spRingSpeed = 10; spRingRange = 80; triggerSPVisual();
  spBoostTimer = 240;
  spCountdownTimer = 240;
  spCountdownValue = 3;
  addPopup(String(spScore), cvs.width/2, cvs.height/2, 1800, 'sp');
  addPopup('', 0, 0, 180, 'flash');
  for(let i=0;i<6;i++){
    if(Math.random()<0.5){
      spValue = Math.min(SP_MAX, spValue + 600);
      skillHistory.unshift({text:`[SPゲージ獲得]`, life:180});
      if(skillHistory.length>5) skillHistory.pop();
    }
  }
  if(Math.random() < 0.5){
    spScoreBuffNotes = 15;
    skillHistory.unshift({text: "[アピール増加 10%]", life:180});
    if(skillHistory.length>5) skillHistory.pop();
  }
  updateACOnSPUse(nowTime, spScore);
  return true;
}
  
function handlePointer(e){
  if(gameState!=="playing") return;
  const isTouch = e.type.startsWith('touch');
  if(isTouch){ lastInputWasTouch=true; e.preventDefault(); }
  if(!isTouch && lastInputWasTouch){ lastInputWasTouch=false; return; }
  const rect=cvs.getBoundingClientRect();
  const clientX = isTouch ? e.touches[0].clientX : e.clientX;
  const clientY = isTouch ? e.touches[0].clientY : e.clientY;
  const scaleX = cvs.width  / rect.width;
  const scaleY = cvs.height / rect.height;
  const mx=(clientX-rect.left)*scaleX;
  const my=(clientY-rect.top )*scaleY;

  // SP半円内のタップなら…
  if(isInSPSemicircle(mx,my)){
    // SP満タン時だけ発動
    if(spValue >= SP_MAX){
      tryUseSP(mx,my); // SP発動
    }
    // SPが満タンでない場合は何もしない（MISSにしない）
    return;
  }
  // それ以外はノーツ判定
  if(judgeNotesGlobal()) return;
  applyMiss('MISS');
}
  
cvs.addEventListener('touchstart',handlePointer,{passive:false});
cvs.addEventListener('click',handlePointer);

startBtn.onclick = async function() {
  await loadTapSE();
  assignACNoteIndexes();
  if(gameState === "init"){
    chartIndex = 0;
    totalNotesSpawned = 0;
    notes = [];
    spValue=0; spFullNotified=false;
    score=0; combo=0;
    skillHistory = [];
    appealBoostNotes = 0;
    skillActivationCount = 0;
    spUseCount = 0;
    progressDisplay = 0;
    spFlashTimer=0; spRingTimer=0; spRingSpeed=20; spRingRange=40;
    spBoostTimer=0;
    spCountdownTimer=0;
    spCountdownValue=0;
    spScoreBuffNotes = 0;
    popups=[]; hitRings=[];
    frame = 0;
    countdownValue = 3;
    judgeCount = {CRITICAL:0,WONDERFUL:0,GREAT:0,NICE:0,BAD:0,MISS:0};
    noteCounter = 0;
    totalSPUsed = 0;

    // --- ★ 永続バフ初期化&50%で発動処理 ---
    permanentScoreBuff = 0;
    if(Math.random() < 0.5){
      permanentScoreBuff++;
      skillHistory.unshift({text:"[アピール増加永続 5%]", life:180});
      if(skillHistory.length>5) skillHistory.pop();
    }

    // AC状態リセット
    acList.forEach(ac=>{
      ac.state = "waiting";
      ac.progress = 0;
      ac.cleared = false;
      ac.tapScore = 0;
      ac.spScore = 0;
    });
    gameState = "countdown";
    resizeCanvas();
    startBtn.style.display = "none";
    retryBtn.style.display = "none";
  }
};
  
// --- リトライボタン挙動 ---
retryBtn.onclick = ()=>{
  gameState = "init";
  startBtn.style.display = "block";
  retryBtn.style.display = "none";
  resizeCanvas();
  try{ bgm.pause(); }catch(e){}
  bgm.currentTime = 0;
  permanentScoreBuff = 0;
  acList.forEach(ac=>{
    ac.state = "waiting";
    ac.progress = 0;
    ac.cleared = false;
    ac.tapScore = 0;
    ac.spScore = 0;
  });
};

// ノーツ出現時にchartIdxを渡すよう修正
function update(){
  frame++;
  if(gameState==="countdown"){
    if(frame % 60 === 0 && countdownValue>0){
      countdownValue--;
      if(countdownValue===0){
        setTimeout(()=>{
          gameState="playing";
          frame = 0;
          bgm.currentTime = 0;
          bgm.volume = 0.10;
          bgm.play().catch(()=>{});
        },1000);
      }
    }
    if(acFailFlashTimer > 0) acFailFlashTimer--;
    return;
  }
  if (gameState === "playing" && !bgm.paused) {
    const bgmNowSec = bgm.currentTime;
    while (chartIndex < notesChart.length && bgmNowSec >= notesChart[chartIndex].time) {
      spawnNote(notesChart[chartIndex].side, chartIndex); // ←ここでchartIndexを渡す！
      totalNotesSpawned++;
      chartIndex++;
    }
    if(acFailFlashTimer > 0) acFailFlashTimer--;
  }
  for(const n of notes) n.t++;
  const keep=[];for(const n of notes){if(n.t<=n.duration+5) keep.push(n);else applyMiss('MISS');}notes=keep;
  if(gameState==="playing" && chartIndex>=notesChart.length && notes.length===0){
    if(waitingClearFrame === null){
      waitingClearFrame = frame;
    }
    if(frame - waitingClearFrame >= 120){
      gameState="clear";
      clearStartFrame=frame;
      waitingClearFrame = null;
      let fadeOut = setInterval(() => {
        if (bgm.volume > 0.02) { bgm.volume -= 0.02; }
        else { bgm.pause(); bgm.currentTime = 0; clearInterval(fadeOut); bgm.volume = 0.10; }
      }, 50);
    }
  } else {
    waitingClearFrame = null;
  }
  if(gameState==="clear" && frame-clearStartFrame>120){
    gameState="result";
    resultStartFrame=frame;
    if(score > bestScore) {
      bestScore = score;
      localStorage.setItem('bestScore', bestScore);
    }
  }

  if(spValue>=SP_MAX){ if(!spFullNotified){ triggerSPVisual(); spFullNotified=true; } }
  else spFullNotified=false;
  if(spCountdownTimer>0){ spCountdownTimer--; if(spCountdownTimer % 60 === 0){ spCountdownValue = Math.max(0, spCountdownValue-1); } }
  const clearedNotes = chartIndex - notes.length;
  const targetProgress = notesChart.length>0 ? Math.min(1, clearedNotes / notesChart.length) : 0;
  progressDisplay += (targetProgress - progressDisplay) * 0.2;
  skillHistory.forEach(h=>h.life--);skillHistory = skillHistory.filter(h=>h.life>0);
  if(spFlashTimer>0) spFlashTimer--;
  if(spRingTimer>0)  spRingTimer--;
  if(spBoostTimer>0) spBoostTimer--;
  hitRings=hitRings.filter(r=>{r.r+=4; r.alpha-=0.06; return r.alpha>0;});
  popups=popups.filter(p=>{p.timer--; return p.timer>0;});
  }
  
// --- ノーツ描画 ---
function drawNotes(){
  for(let i=0;i<notes.length;i++){
    const n = notes[i];
    const noteInfo = notesChart[n.chartIdx];
    if(!noteInfo) continue;
    const noteTime = noteInfo.time;
    const idx = n.chartIdx;

    // AC区間に入っているか（indexベースで判定）
    let isAcCleared = false;
    for(const ac of acList){
      if(ac.state === "cleared" && ac.startIdx !== -1 && ac.endIdx !== -1 && idx >= ac.startIdx && idx <= ac.endIdx){
        isAcCleared = true;
        break;
      }
    }

    // 色設定
    let mainColor = isAcCleared ? "#ffd700" : "#00eaff";
    let glowColor = isAcCleared ? "rgba(255,220,60,0.7)" : "rgba(0,200,255,0.7)";
    let rimColor  = isAcCleared ? "#ffe777" : "#7fffff";
    let dotColor  = isAcCleared ? "#ffe066" : "#1cd9ee";

    const pos = cubicBezier(n.path.p0, n.path.p1, n.path.p2, n.path.p3, Math.min(1, n.t/n.duration));
    const r = R;

    // --- 1. 外側グロー ---
    ctx.save();
    ctx.globalAlpha = 0.90;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, r * 1.15, 0, Math.PI * 2);
    const glow = ctx.createRadialGradient(pos.x, pos.y, r * 0.6, pos.x, pos.y, r * 1.2);
    glow.addColorStop(0, glowColor);
    glow.addColorStop(0.7, isAcCleared ? "rgba(255,220,60,0.15)" : "rgba(0,200,255,0.18)");
    glow.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = glow;
    ctx.fill();
    ctx.restore();

    // --- 2. 外枠リム ---
    ctx.save();
    ctx.strokeStyle = rimColor;
    ctx.lineWidth = r * 0.18;
    ctx.globalAlpha = 0.82;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, r * 0.87, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    // --- 3. 主円 ---
    ctx.save();
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, r * 0.72, 0, Math.PI * 2);
    ctx.fillStyle = mainColor;
    ctx.shadowColor = mainColor;
    ctx.shadowBlur = r * 0.16;
    ctx.globalAlpha = isAcCleared ? 0.72 : 0.6;
    ctx.fill();
    ctx.restore();

    // --- 4. 中心ドット ---
    ctx.save();
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, r * 0.22, 0, Math.PI * 2);
    ctx.fillStyle = dotColor;
    ctx.globalAlpha = 0.88;
    ctx.fill();
    ctx.restore();

    // --- START/FINISHラベル（indexで判定）---
    for(const ac of acList){
      if(ac.startIdx === idx){
        ctx.font = `bold ${Math.round(R*0.8)}px system-ui`;
        ctx.textAlign = "center";
        ctx.lineWidth = 4;
        ctx.strokeStyle = "#fff";
        ctx.strokeText("START", pos.x, pos.y+R+13);
        ctx.fillStyle = "#ff69b4";
        ctx.fillText("START", pos.x, pos.y+R+13);
      }
      if(ac.endIdx === idx){
        ctx.font = `bold ${Math.round(R*0.8)}px system-ui`;
        ctx.textAlign = "center";
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#ff69b4";
        ctx.strokeText("FINISH", pos.x, pos.y+R+13);
        ctx.fillStyle = "#fff";
        ctx.fillText("FINISH", pos.x, pos.y+R+13);
      }
    }
  }
}
  
// --- AC通知パネル ---
function drawACMissionNotice(){
  let nowTime = bgm.currentTime || 0;
  const ac = acList.find(ac => (ac.state === "active" || ac.state === "cleared") &&
    nowTime >= ac.startTime + noteTravelSec && nowTime <= ac.endTime + noteTravelSec);
  if(!ac) return;
  // 横幅を広く&進捗バーより下で中央より上位置
  const barMarginLeft = 20;
  const barMarginRight = 200;
  const barWidth = Math.max(140, cvs.width - barMarginLeft - barMarginRight);
  const w = Math.max(cvs.width * 0.6, 400);
  const h = Math.max(30, Math.round(cvs.height*0.035));
  const x = (cvs.width-w)/2;
  const y = Math.max( barWidth*0.02+50, cvs.height*0.12 );
  ctx.save();
  ctx.textAlign = "center";
  ctx.font = `bold ${Math.round(h*0.4)}px system-ui`;
  ctx.lineWidth = 3;
  ctx.strokeStyle = ac.cleared ? "#FFD700" : "#ff69b4";
  ctx.fillStyle = ac.cleared ? "#FFD700" : "#ff69b4";
  ctx.globalAlpha = 0.82;
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, 13);
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.stroke();
  ctx.fillStyle = "#fff";
  ctx.globalAlpha = 1;
  let text = ac.type === "score" ? `AC: ${ac.desc}（${ac.progress|0}/${ac.target}）` : `AC: ${ac.desc}（${ac.progress|0}/${ac.target}）`;
  if(ac.cleared) text = "ACクリア！ " + text;
  ctx.fillText(text, x+w/2, y+h/2+2);
  ctx.restore();
}

// --- 進捗バー ピンクAC区間（time基準・修正版） ---
function drawProgressBarAC(){
  const barMarginLeft = 20;
  const barMarginRight = 200;
  const barWidth = Math.max(140, cvs.width - barMarginLeft - barMarginRight);
  const barHeight = 12;
  const x = barMarginLeft;
  const y = 10;
  const lastTime = notesChart[notesChart.length-1].time;
  // ACピンク区間（下地）
  for(const ac of acList){
    const startRatio = (ac.startTime + noteTravelSec) / (lastTime + noteTravelSec);
    const endRatio = (ac.endTime + noteTravelSec) / (lastTime + noteTravelSec);
    ctx.fillStyle = "#ff69b4";
    ctx.globalAlpha = 0.35;
    ctx.fillRect(x + barWidth*startRatio, y, barWidth*(endRatio-startRatio), barHeight);
    ctx.globalAlpha = 1;
    // 進捗（クリア時黄色、未クリア白）を上に細く重ねて表示
    if(ac.state === "active" || ac.state === "cleared"){
      let nowTime = bgm.currentTime || 0;
      if(nowTime >= ac.startTime + noteTravelSec && nowTime <= ac.endTime + noteTravelSec && ac.target > 0){
        let progressRatio = ac.type === "score"
          ? Math.min(1, (ac.progress || 0) / ac.target)
          : Math.min(1, (ac.progress || 0) / ac.target);
        ctx.fillStyle = ac.cleared ? "#FFD700" : "#fff";
        ctx.globalAlpha = 0.90;
        ctx.fillRect(
          x + barWidth*startRatio,
          y-5,
          barWidth*(endRatio-startRatio)*progressRatio,
          5
        );
        ctx.globalAlpha = 1;
      }
    }
  }
}

// --- 以降は描画処理など ---
function strokeRainbowText(text,x,y,font){
  ctx.textAlign='center'; ctx.font=font;
  const g=ctx.createLinearGradient(x-100,y,x+100,y);
  const hue=(frame*4)%360;
  for(let i=0;i<=6;i++) g.addColorStop(i/6,`hsl(${(hue+i*60)%360},100%,50%)`);
  ctx.lineWidth=4; ctx.strokeStyle=g; ctx.strokeText(text,x,y);
  ctx.fillStyle='#fff'; ctx.fillText(text,x,y);
}
function strokeColoredText(text,x,y,font,color){
  ctx.textAlign='center'; ctx.font=font;
  ctx.lineWidth=4; ctx.strokeStyle=color; ctx.strokeText(text,x,y);
  ctx.fillStyle='#fff'; ctx.fillText(text,x,y);
}
function strokeOrangeWhiteText(text,x,y,font){
  ctx.textAlign='center'; ctx.font=font;
  ctx.lineWidth=6; ctx.strokeStyle='#fff'; ctx.strokeText(text,x,y);
  ctx.fillStyle='#ffa500'; ctx.fillText(text,x,y);
}
function drawProgressBar(){
  const barMarginLeft = 20;
  const barMarginRight = 200;
  const barWidth = Math.max(140, cvs.width - barMarginLeft - barMarginRight);
  const barHeight = 12;
  const x = barMarginLeft;
  const y = 10;
  ctx.fillStyle = '#4b5563';
  ctx.fillRect(x, y, barWidth, barHeight);
  ctx.fillStyle = '#00e5ff';
  ctx.fillRect(x, y, barWidth * progressDisplay, barHeight);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, barWidth, barHeight);
}
function drawSkillHistory(){
  const maxItems = 5;
  const lineH = Math.max(16, Math.round(R*0.6));
  const padding = 6;
  const x = 22;
  const startY = cvs.height - 22 - (maxItems-1)*lineH;
  ctx.textAlign='left';
  ctx.font=`bold ${lineH}px system-ui`;
  const items = skillHistory.slice(0, maxItems);
  for(let i=0;i<items.length;i++){
    const h=items[i];
    let alpha = 1;
    if(h.life < 30) alpha = h.life/30;
    ctx.globalAlpha = alpha;
    const text = h.text;
    const w = ctx.measureText(text).width;
    ctx.fillStyle='rgba(0,0,0,0.4)';
    ctx.fillRect(x-2, startY + i*lineH - (lineH-padding/2), w+16, lineH+padding/2);
    ctx.fillStyle='#e5faff';
    ctx.fillText(text, x, startY + i*lineH);
    ctx.globalAlpha = 1;
  }
}
function drawTargets(){
  ctx.strokeStyle='#fff'; ctx.lineWidth=3;
  for(const t of [leftTarget,rightTarget]){
    ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.stroke();
  }
}

function drawHitRings(){
  for(const ring of hitRings){
    ctx.strokeStyle=`rgba(255,255,255,${ring.alpha})`;
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(ring.x,ring.y,ring.r,0,Math.PI*2); ctx.stroke();
  }
}
function drawSPGauge(){
  const cx=cvs.width/2, cy=cvs.height-10, radius=spRadius;
  const startAngle=Math.PI, endAngle=0;
  ctx.strokeStyle='#fff'; ctx.lineWidth=4;
  ctx.beginPath(); ctx.arc(cx,cy,radius,startAngle,endAngle,false); ctx.stroke();
  const fillRatio=Math.min(1, spValue/SP_MAX);
  const fillEnd=startAngle + Math.PI*fillRatio;
  ctx.fillStyle='#fff';
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,radius,startAngle,fillEnd,false); ctx.closePath(); ctx.fill();
  const nx=cx+Math.cos(fillEnd)*(radius-10), ny=cy+Math.sin(fillEnd)*(radius-10);
  ctx.strokeStyle='#fff'; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.stroke();
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(cx,cy,Math.max(3, radius*0.06),0,Math.PI*2); ctx.fill();

  // ★満タン時発光エフェクト
  if(spValue >= SP_MAX){
    ctx.save();
    ctx.globalAlpha = 0.33; // 薄い発光
    ctx.strokeStyle = '#ffff99'; // 薄い黄色
    ctx.lineWidth = 16;
    ctx.beginPath();
    ctx.arc(cx, cy, radius+6, startAngle, endAngle, false);
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  
  if(spFlashTimer>0){
    ctx.fillStyle=`rgba(255,255,255,${spFlashTimer/10})`;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,radius,startAngle,endAngle,false); ctx.closePath(); ctx.fill();
  }
  if(spRingTimer>0){
    const rp=1 - spRingTimer/spRingSpeed;
    const rr=radius + rp*spRingRange;
    ctx.strokeStyle=`rgba(255,255,255,${1-rp})`;
    ctx.lineWidth=6; ctx.beginPath(); ctx.arc(cx,cy,rr,startAngle,endAngle,false); ctx.stroke();
  }
}
function drawPopups(){
  for(const p of popups){
    const a=p.timer/p.duration; ctx.globalAlpha=a;
    if(p.type==='label'){
      let fontSize = Math.max(28, Math.round(R*1.2), Math.round(cvs.height*0.055));
      if(p.text==='CRITICAL'){
        ctx.fillStyle='#FFD700'; ctx.font=`bold ${fontSize}px system-ui`; ctx.textAlign='center';
        ctx.fillText('★', p.x-fontSize*2, p.y);
        ctx.fillText('★', p.x+fontSize*2, p.y);
        strokeRainbowText('CRITICAL', p.x, p.y, `bold ${fontSize}px system-ui`);
      }else if(p.text==='WONDERFUL'){
        strokeRainbowText('WONDERFUL', p.x, p.y, `bold ${fontSize}px system-ui`);
      }else if(p.text==='GREAT'){
        strokeColoredText('GREAT', p.x, p.y, `bold ${fontSize}px system-ui`, '#ff69b4');
      }else if(p.text==='NICE'){
        strokeColoredText('NICE', p.x, p.y, `bold ${fontSize}px system-ui`, '#ffd700');
      }else if(p.text==='BAD' || p.text==='MISS'){
        strokeColoredText(p.text, p.x, p.y, `bold ${fontSize}px system-ui`, '#9ca3af');
      }
    }else if(p.type==='score'){
      let fontSize = Math.max(26, Math.round(R*1.0), Math.round(cvs.height*0.045));
      strokeColoredText(p.text, p.x, p.y, `bold ${fontSize}px system-ui`, '#39ff14');
    }else if(p.type==='sp'){
      let fontSize = Math.max(54, Math.round(R*2.1), Math.round(cvs.height*0.11));
      strokeOrangeWhiteText(p.text, p.x, p.y, `bold ${fontSize}px system-ui`);
    }
    ctx.globalAlpha=1;
  }
}
function drawUI(){
  if(gameState!=="playing") return;
  const cx=cvs.width - Math.max(40, Math.round(R*1.8));
  ctx.textAlign='center'; ctx.fillStyle='#fff';
  ctx.font=`bold ${Math.max(20,Math.round(R*1.0))}px system-ui`; ctx.fillText(`${combo}`, cx, Math.max(24,Math.round(R*1.0)));
  ctx.font=`bold ${Math.max(10,Math.round(R*0.5))}px system-ui`; ctx.fillText('COMBO', cx, Math.max(40,Math.round(R*1.6)));
  ctx.textAlign='right'; ctx.font=`bold ${Math.max(16,Math.round(R*0.7))}px system-ui`;
  ctx.fillText(`Score: ${score}`, cvs.width-12, cvs.height-16);
}
function drawOverlays(){
  const f=popups.find(p=>p.type==='flash');
  if(f){
    ctx.fillStyle=`rgba(255,255,255,${f.timer/f.duration*0.6})`;
    ctx.fillRect(0,0,cvs.width,cvs.height);
  }
}
function drawSPCountdown(){
  if(spCountdownTimer<=0) return;
  if(spCountdownValue===0 && Math.floor(frame/8)%2===0) return;
  const x=cvs.width/2, y=Math.round(cvs.height*0.25);
  ctx.textAlign='center';
  ctx.font=`bold ${Math.max(48,Math.round(R*2.0))}px system-ui`;
  const g=ctx.createLinearGradient(x-80,y,x+80,y);
  const hue=(frame*4)%360;
  for(let i=0;i<=6;i++) g.addColorStop(i/6, `hsl(${(hue+i*60)%360},100%,50%)`);
  ctx.lineWidth=8; ctx.strokeStyle=g; ctx.strokeText(spCountdownValue, x, y);
  ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText(spCountdownValue, x, y);
}

function drawACFailFlash(){
  if(acFailFlashTimer > 0){
    const alpha = Math.min(0.38, acFailFlashTimer/18*0.38);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "#ff0033";
    ctx.fillRect(0,0,cvs.width,cvs.height);
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}
  
// ★ 判定回数リザルト左下表示
function drawJudgeCountsResult() {
  const baseX = 30;
  const baseY = cvs.height - 28;
  const lineH = Math.max(14, Math.round(cvs.height * 0.03));
  const labels = ["CRITICAL", "WONDERFUL", "GREAT", "NICE", "BAD", "MISS"];
  ctx.save();
  ctx.textBaseline = 'top';
  ctx.font = `bold ${lineH}px system-ui`;
  // 幅確保
  let maxLabelWidth = 0, maxCountWidth = 0;
  for(const l of labels) {
    const w1 = ctx.measureText(l).width;
    const w2 = ctx.measureText(judgeCount[l].toString()).width;
    if(w1>maxLabelWidth) maxLabelWidth = w1;
    if(w2>maxCountWidth) maxCountWidth = w2;
  }
  const gap = 16;
  for(let i=0;i<labels.length;i++){
    const l = labels[i];
    const y = baseY - lineH * (labels.length - i);
    ctx.textAlign = 'left';
    ctx.fillStyle = "#fff";
    ctx.globalAlpha = 0.82;
    ctx.fillText(l, baseX, y);

    ctx.textAlign = 'right';
    ctx.fillStyle = "#ffd700";
    ctx.globalAlpha = 0.94;
    ctx.fillText(judgeCount[l], baseX + maxLabelWidth + gap + maxCountWidth, y);
  }
  ctx.globalAlpha = 1.0;
  ctx.restore();
}

function render(){
   ctx.clearRect(0,0,cvs.width,cvs.height);
  // 背景画像（30%不透明度）をcanvas全体に描画
  if(bgimg.complete && bgimg.naturalWidth > 0) {
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.drawImage(bgimg, 0, 0, cvs.width, cvs.height);
    ctx.globalAlpha = 1;
    ctx.restore();
  } else {
    ctx.fillStyle = "#0f172a";
    ctx.fillRect(0,0,cvs.width,cvs.height);
  }
  
  drawProgressBarAC();
  drawTargets();
  drawNotes();
  drawHitRings();
  drawSPGauge();
  drawPopups();
  drawUI();
  drawOverlays();
  drawProgressBar();
  drawSkillHistory();
  drawACMissionNotice();
  drawACFailFlash();
  
  if(gameState==="init"){ return; }
  if(gameState==="countdown"){
    const txt = countdownValue>0 ? countdownValue : 1;
    ctx.textAlign='center';
    ctx.font=`bold ${Math.round(cvs.height*0.22)}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#000'; ctx.strokeText(txt, cvs.width/2, cvs.height/2);
    ctx.fillStyle='#fff'; ctx.fillText(txt, cvs.width/2, cvs.height/2);
    return;
  }
  drawSPCountdown();
  if(gameState==="clear"){
    ctx.textAlign='center';
    ctx.font=`bold ${Math.round(cvs.height*0.14)}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#fff'; ctx.strokeText('CLEAR', cvs.width/2, cvs.height/2);
    ctx.fillStyle='#ffa500'; ctx.fillText('CLEAR', cvs.width/2, cvs.height/2);
    return;
  }
  if(gameState==="result"){
    retryBtn.style.display = "block";
    const t = Math.min(1, (frame - (resultStartFrame||frame)) / 60);
    const scale = 0.8 + 0.2*Math.sin(t*Math.PI/2);
    const alpha = 0.5 + 0.5*t;
    ctx.save();
    ctx.translate(cvs.width/2, cvs.height/2);
    ctx.scale(scale, scale);
    ctx.textAlign='center';

    ctx.font=`bold ${Math.round(cvs.height*0.10)}px system-ui`;
    ctx.lineWidth=8; ctx.strokeStyle='#000'; ctx.strokeText('RESULT', 0, -90);
    ctx.fillStyle='#ffa500'; ctx.fillText('RESULT', 0, -90);

    // 曲名
    const scoreFontSize = Math.round(cvs.height*0.07);
    ctx.font = `bold ${scoreFontSize}px system-ui`;
    ctx.lineWidth = 8;
    ctx.strokeStyle = "#000";
    ctx.strokeText("ユメ語るよりユメ歌おう", 0, -36);
    ctx.fillStyle = "#fff";
    ctx.fillText("ユメ語るよりユメ歌おう", 0, -36);

    // SCORE
    ctx.font=`bold ${scoreFontSize}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#000'; ctx.strokeText(`SCORE: ${score}`, 0, 0);
    ctx.fillStyle='#39ff14'; ctx.fillText(`SCORE: ${score}`, 0, 0);
    // ★BEST SCORE表示
    ctx.font=`bold ${scoreFontSize*0.8}px system-ui`;
    ctx.lineWidth=8;
    ctx.strokeStyle="#000";
    ctx.strokeText(`BEST SCORE: ${bestScore}`, 0, 28);
    ctx.fillStyle="#ffd700";
    ctx.fillText(`BEST SCORE: ${bestScore}`, 0, 28);

    ctx.font=`bold ${Math.round(cvs.height*0.04)}px system-ui`;
    ctx.lineWidth=6; ctx.strokeStyle='#000';
    ctx.strokeText(`特技発動回数: ${skillActivationCount}`, 0, 60);
    ctx.strokeText(`SP使用回数: ${spUseCount}`, 0, 80);
    ctx.fillStyle='#e5faff';
    ctx.fillText(`特技発動回数: ${skillActivationCount}`, 0, 60);
    ctx.fillText(`SP使用回数: ${spUseCount}`, 0, 80);

    ctx.restore();
    drawJudgeCountsResult();
    return;
  } else {
    retryBtn.style.display = "none";
  }
}
function loop(){ update(); render(); requestAnimationFrame(loop); }
(function start(){ loop(); })();

</script>
</body>
</html>




